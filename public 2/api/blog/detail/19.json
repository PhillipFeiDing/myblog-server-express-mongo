{
    "data": {
        "id": 19,
        "content": "<h2><span style=\"font-weight: 700; color: rgb(194, 79, 74);\">Problem 239</span></h2><h3><span style=\"color: rgb(77, 128, 191);\"><span style=\"font-weight: bold;\"></span>Keyword: Max, Sliding Window, Deque</span></h3><h3><span style=\"color: rgb(77, 128, 191);\">Description:</span></h3><p>Given an array&nbsp;<em>nums</em>, there is a sliding window of size&nbsp;<em>k</em>&nbsp;which is moving from the very left of the array to the very right. You can only see the&nbsp;<em>k</em>&nbsp;numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p><strong>Follow up:</strong><br>Could you solve it in linear time?</p><p><strong>Example:</strong></p><pre><strong>Input:</strong> <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3\n<strong>Output: </strong><code>[3,3,5,5,6,7] \n<strong>Explanation: \n</strong></code>\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong></pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4&nbsp;&lt;= nums[i]&nbsp;&lt;= 10^4</code></li><li><code>1 &lt;= k&nbsp;&lt;= nums.length</code></li></ul><h3><span style=\"color: rgb(77, 128, 191);\">Solution:</span></h3><p>Maintain a deque recording the array indices of the useful elements in the current sliding window. An element is useful when it is greater than all elements to its left in the sliding window. The indices in the deque are ordered such that their corresponding elements in the array are sorted from the greatest to the smallest. Particularly, the head of the deque records the index of the greatest element in the sliding window. Also, the relative positioning of the element in the array is preserved in the deque as well.</p><p>In each iteration, as we initially expand or continuous move the sliding window, each time a new element is added into the back of the deck in the following way: it finds its position by \"knocking out\" elements from the back of the deque until it meets an element which is larger than itself or until the deque is empty. In this way, Elements that just became useless because of this added element are dropped out, and the order property of the deque is preserved. Then, we will check the front of the deque to ensure the current largest element is still present in the sliding window. This is particularly easy because we store indices of elements instead of elements themselves; therefore, we will possibly remove the old maximum which just \"aged out\" from the front of the dequeue to keep our recording most up-to-date, and the next maximum may emerge.</p><p>At the end of each iteration, after the deque has been updated, we simply peek the front of the deque to retrieve the current maximum.</p><h3><span style=\"color: rgb(77, 128, 191);\">Code:</span></h3><pre><code>class Solution {<br>    public int[] maxSlidingWindow(int[] nums, int k) {<br>        int[] result = new int[nums.length - k + 1];<br>        Deque&lt;Integer&gt; sortedIdx = new LinkedList&lt;&gt;();<br>        for (int i = 0; i &lt; nums.length; i++) {<br>            while (!sortedIdx.isEmpty() &amp;&amp; nums[sortedIdx.peekLast()] &lt; nums[i]) {<br>                sortedIdx.removeLast();<br>            }<br>            sortedIdx.addLast(i);<br>            if (i &gt;= k) {<br>                while (sortedIdx.peekFirst() &lt;= i - k) {<br>                    sortedIdx.removeFirst();<br>                }<br>            }<br>            if (i &gt;= k - 1) {<br>                result[i - k + 1] = nums[sortedIdx.peekFirst()];<br>            }<br>        }<br>        return result;<br>    }<br>}</code></pre><p><br></p><ul>\n</ul>",
        "time": 1587705720000,
        "exerpt": "Here I choose to record the solutions I used to solve the LeetCode problems that I think worth studying. Many of them can be solved with drastically different algorithms and data structures. I try to mention all of them but ultimately come up with the thinking and code for the optimal solution. Most codes are in Java, and the rest may be in Python.",
        "tagList": [10],
        "title": "LeetCode Problems Diary",
        "imageURL": ""
    },
    "errno": 0
}