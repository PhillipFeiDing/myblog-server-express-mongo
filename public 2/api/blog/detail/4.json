{
    "data": {
        "id": 4,
        "content": "<p style=\"text-align: center; \"><img src=\"https://raw.githubusercontent.com/PhillipFeiDing/myblog-resource/master/maze-generator-solver/maze-new.gif\" style=\"max-width:100%;\"><br></p><h1>Background</h1><p><span style=\"font-size: large;\">Recently I became obsessed with how mazes, which you can usually find at the back of a magazine, are automatically generated. At first, I think they must have been produced by extremely advanced algorithms that few people can understand. However, it was only through the process of solving an actual maze, which extensively applies various classical search algorithms, that I suspect the same procedure in a reverse manner might be effective in generating one. Luckily, by coding an actual prototype, it turns out that my program can answer both questions for me. By randomly combining DFS (Depth First Search) and BFS (Breadth First Search) backed by a deque*, I am able to create my own challenging maze and then solve it with the help of this simulation tool.</span></p><div><span style=\"font-size: large;\"><br>* deque, a data structure that supports both adding and removing from both the head and the tail upon your choice. More general than stack (LIFO) and queue (FIFO).</span></div><p><br></p><p style=\"text-align: center;\"><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/deque.png\"><br></p><p style=\"text-align: center;\"><br></p><div><h1>How I Made It</h1></div><p><span style=\"font-size: large;\">This simulation is powered by Java Swing, a very old (outdated) yet mature GUI framework popular in the early 2000s. The project is public on GitHub as a repository and spans as an IntelliJ project, so opening this in IntelliJ will allow you to run it and directly change some maze parameters in the main class (AlgoVisualizer). See details at the bottom.<br><br>Below you will see a video demo of this simulation project.</span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: center;\"><iframe width=\"840\" src=\"https://www.youtube.com/embed/_rair44FJCQ\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" height:=\"\" height=\"472\"></iframe></p><p><br></p><p><br></p><h2>Maze Generator</h2><p><span style=\"font-size: large;\">The generator is a bit more complicated than the solver which clearly applies some search algorithm. To make search algorithms work on the maze generating task we need to do a little modification: instead of directly producing a maze, we first manually make a grid of walls where each cell is disconnected from others. Then, we choose a starting cell and randomly decide which wall to break. After that, we take the connected adjacent cell into consideration and continue the process of breaking walls. If we conceive each breakable wall as a valid element in our collection, of which the current ones we are considering to break are in our open list (here a deque). Removing a piece of wall means opening a new cell and will bring two or three more breakable walls to consider, which will be added randomly to either the head or the tail of the deque. Do this until we open up the entire maze. One thing to notice here is that we need to break walls in a manner that we produce no cycle in the maze, so we will also keep track of visited cells using a set. Bingo, now we have a maze generating process backed by a customized search algorithm.</span></p><p><br></p><p style=\"text-align: center;\"><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/grid.png\"><span style=\"color: rgb(255, 255, 255);\">--------------------</span><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/breakable_walls.png\"><br></p><p><br></p><h2>Maze Solver</h2><p><span style=\"font-size: large;\">The maze solver is much simpler, and a simple DFS will suffice. DFS is particularly useful in this case because backtracking a path is very easy and natural with a stack.</span></p><p><br></p><p style=\"text-align: center;\"><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/maze_solved.png\" style=\"max-width:100%; width: 500px;\"><span style=\"color: rgb(255, 255, 255);\">-----</span><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/backtracking.png\" style=\"max-width: 100%; width: 500px;\"><br></p><p><br></p><div><h1>Final Words</h1></div><p><span style=\"font-size: large;\">I believe this interesting maze generator/solver is the first step toward artificial intelligence. In fact, people all agree that search algorithms are actually the earliest AI approaches used in the industry. Despite being simple to implement, they have various applications in spacial navigation, route planning, and puzzle solving. On the other hand, they have certainly invited and inspired the appearance of other more advanced AI algorithms.</span><br></p><p><br></p><p style=\"text-align: center;\"><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/navigation.jpg\" style=\"max-width:100%; width: 300px;\"><span style=\"color: rgb(255, 255, 255);\">----------</span><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/robot.jpeg\" style=\"max-width: 100%; width: 300px;\"><span style=\"color: rgb(255, 255, 255);\">----------</span><img src=\"https://github.com/PhillipFeiDing/myblog-resource/raw/master/maze-generator-solver/chess.jpg\" style=\"max-width: 100%; width: 300px;\"><br></p><p style=\"text-align: center;\"><br></p><div><h1>Repository Link</h1><p style=\"text-align: center;\"><a href=\"https://github.com/PhillipFeiDing/java-swing-demos/tree/master/RandomMazeGenerator%20%2B%20Solver\" target=\"_blank\" style=\"font-size: large;\">Link to GitHub</a><br></p></div>",
        "time": 1533304800000,
        "exerpt": "Recently I became obsessed with how mazes, which you can usually find at the back of a magazine, are automatically generated. At first, I think they must have been produced by extremely advanced algorithms that few people can understand. However, it was only through the process of solving an actual maze, which extensively applies various classical search algorithms, that I suspect the same procedure in a reverse manner might be effective in generating one. Luckily, by coding an actual prototype, it turns out that my program can answer both questions for me.",
        "tagList": [2, 7],
        "title": "Maze Generator and Solver",
        "imageURL": "https://github.com/PhillipFeiDing/myblog-resource/blob/master/blog-cover-image/maze.gif?raw=true"
    },
    "errno": 0
}