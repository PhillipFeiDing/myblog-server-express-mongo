{
    "data": {
        "id": 7,
        "content": "<p></p><h1 style=\"text-align: center;\"><img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/computational-physics-model/balls.gif?raw=true\" style=\"max-width:100%; width: 800px; margin-bottom: 60px; border-radius: 40px;\"><br></h1><h1>Background</h1><p><span style=\"font-size: large;\">As a progressive learner trying to master the Java language, I taught myself some GUI programming under the Swing framework, just to discover their usefulness in building and visualizing real world models. More precisely, I could make computational physics models by writing very simple and self-explanatory codes. Though more advanced commercial simulation tools might do a better job in both representing and rendering such models, coding them on my own has certainly enriched my knowledge of GUI programming, and hopefully, has helped me review some physics …, but most importantly, they are fun and interesting.</span><br></p><br><h1>How I Made It</h1><p><span style=\"font-size: large;\">First, I needed to construct a model, and before that I’d better be clear with what I would like to simulate. The simplest yet dynamic model I could come up with consists a collection of circles (assuming a 2D environment) in motion colliding with each other. Even such a simple model could pose challenges for a beginner programmer. There are two main problems to solve.</span><br></p><p></p><ul><li><p><span style=\"font-size: large;\">How to encode each object’s position and velocity (state) in the 2D space?</span></p></li><li><p><span style=\"font-size: large;\">How to calculate the effect of collision?&nbsp;</span></p></li></ul><p><span style=\"font-size: large;\">To solve the first problem, I resolved to principles of object-oriented programming. OOP provides a wonderful model for encapsulation, with which we can easily define the attributes of each circle objects, including its center coordinates, velocity, and radius in an organized manner. These attributes have been proven adequate in representing the motion state of a circle.<br>The second one is trickier, assuming that you only had a minimal mastery of high school physics education like I did. Luckily, there were numerous tutoring materials on the internet for me to consult with, though I would never be expected to solve 2-D collision problems on an actual physics exam. The formula looks daunting really, yet computers are not feared as they are data-crunching monsters!</span></p><p><span style=\"font-size: large;\"><br></span></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/computational-physics-model/collision.png?raw=true\" style=\"max-width:100%; width: 400px;\">&nbsp;</th><th><img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/computational-physics-model/formula.png?raw=true\" style=\"max-width:100%; width: 635px;\">&nbsp;</th></tr></tbody></table><p><span style=\"font-size: large;\"><br>Now that I had a functioning conceptual model, it’s time to implement in the software. With a pre-written framework like Swing, I spent little time struggling with low-level issues like getting the window frame to set up and could focus on the main simulation and rendering logic. In fact, the latter two came naturally with a simple giant loop. In each iteration, I could let each circle in the model move just a little bit, when they had time for travelling a fraction of second or experiencing an instantaneous collision with another circle. Afterwards, they would be ready to show on the screen. Again, the Swing framework came with mature and reliable rendering APIs to use even with the most primitive painting tasks.</span></p><p><br></p><h1>And More</h1><p><span style=\"font-size: large;\">What would happen if we make a large number of such circles with this simulation? One thing for sure is that it will slow down my computer because the time needed for computing one frame for the model is proportional to the number of objects in the simulation. But what are the more interesting aspects lying behind this? Let’s find out.</span></p><p><span style=\"font-size: large;\"><br></span></p><div style=\"text-align: center;\"><iframe width=\"840\" height=\"472\" src=\"https://www.youtube.com/embed/ijimI3QST1I\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"></iframe></div><div style=\"text-align: center;\"><br></div><div style=\"text-align: left;\"><br></div><p></p><p><span style=\"font-size: large;\">Above you can see over 500 tiny blue particles along with over 500 red particles, with each group initially occupying one side. As time elapses, you can see them fuse into each other. Surprisingly, this model truthfully simulates the dispersion phenomenon of ideal gases, though with a prohibitively expensive computational cost.</span></p><p><br><span style=\"font-size: large;\">How about gravity? Sure, why not making a solar system? Watch carefully: the simulation gets quite funny at the end.</span></p><p><span style=\"font-size: large;\"><br></span></p><p style=\"text-align: center;\"><iframe width=\"840\" height=\"472\" src=\"https://www.youtube.com/embed/7d1Xd2NBxG8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"></iframe></p><p><br></p><h1>Repository Link</h1><p></p><p style=\"text-align: center;\"><span style=\"font-size: large;\"><a href=\"https://github.com/PhillipFeiDing/java-swing-demos/tree/master/BallCollision\" target=\"_blank\">Circles</a><br></span></p><p style=\"text-align: center;\"><a href=\"https://github.com/PhillipFeiDing/java-swing-demos/tree/master/PlanetaryModel\" target=\"_blank\" style=\"font-size: large;\">Solar System</a><br></p>\n",
        "time": 1527508800000,
        "exerpt": "As a progressive learner trying to master the Java language, I taught myself some GUI programming under the Swing framework, just to discover their usefulness in building and visualizing real world models. More precisely, I could make computational physics models by writing very simple and self-explanatory codes. Though more advanced commercial simulation tools might do a better job in both representing and rendering such models, coding them on my own has certainly enriched my knowledge of GUI programming, and hopefully, has helped me review some physics.",
        "tagList": [2, 5],
        "title": "Computational Physics Model",
        "imageURL": "https://github.com/PhillipFeiDing/myblog-resource/blob/master/blog-cover-image/physics.gif?raw=true"
    },
    "errno": 0
}