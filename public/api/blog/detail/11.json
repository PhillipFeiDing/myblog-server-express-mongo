{
    "data": {
        "id": 11,
        "content": "<h1><span style=\"font-weight: bold;\"></span>Introduction</h1><p><span style=\"font-size: large;\">In computer science and information theory, a Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. The process of finding or using such a code proceeds by means of Huffman coding, an algorithm developed by David A. Huffman while he was a Sc.D. student at MIT, and published in the 1952 paper \"A Method for the Construction of Minimum-Redundancy Codes\". This project provides an implementation of the classical Huffman encoding algorithms, a browser-based (JavaScript) demo interface, and a desktop (Java) utility tool available for download!</span></p><p><span style=\"font-size: large;\"><br></span></p><h1><span style=\"font-weight: normal;\"></span>The Algorithm<br></h1><p><span style=\"font-size: large;\">&nbsp;We already know that every character is stored in sequences\nof 0's and 1's using 8 bits. This is called <span style=\"font-weight: bold; color: rgb(194, 79, 74);\">fixed-length encoding</span> as each\ncharacter uses the same number of fixed bits storage.</span></p><p class=\"MsoNormal\"><span style=\"font-size: large;\"><o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: x-large; font-weight: bold;\">Given a text, how can we reduce the amount of space required\nto store a character?</span><o:p></o:p></p>\n\n<p class=\"MsoNormal\"><o:p>&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">The idea is to use <span style=\"color: rgb(194, 79, 74); font-weight: bold;\">variable-length encoding</span>. We can exploit\nthe fact that some characters occur more frequently than others in a text to\ndesign an algorithm that can represent the same piece of text using lesser\nnumber of bits. In variable-length encoding, we assign variable number of bits\nto characters depending upon their frequency in the given text. So, some\ncharacters might end up taking 1 bit, some might end up taking two bits, some\nwill be encoded using three bits, and so on. The problem with variable-length\nencoding lies in its decoding.</span><o:p></o:p></p>\n\n<p class=\"MsoNormal\"><o:p>&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: x-large; font-weight: bold;\">Given a sequence of bits, how can we decode it uniquely?</span><o:p></o:p></p>\n\n<p class=\"MsoNormal\"><o:p>&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">Let's consider the string \"aabacdab\". It has 8\ncharacters in it and uses 64 bits storage (using fixed-length encoding). If we\nnote, the frequency of characters 'a', 'b', 'c', and 'd' are 4, 2, 1, 1\nrespectively. Let's try to represent \"aabacdab\" using lesser number\nof bits by the fact that 'a' occurs more frequently than 'b' and 'b'\noccurs more frequently than 'b' and 'b' occurs more frequently than 'c' and\n'd'. We start by randomly assigning single bit code 0 to 'a', 2-bit code 11 'b'\nand 3-bit code 100 and 011 to characters 'c' and 'd' respectively. </span><o:p></o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; <o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; a 0<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; b 11<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; c 100<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; d 011<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">So the string aabacdab will be encoded to 00110100011011\n(0|0|11|0|100|011|0|11) using the above code. But the real problem lies in\ndecoding. If we try to decode the string 00110100011011, it will lead to\nambiguity as it can be decoded to,<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; 0|011|0|100|011|0|11\nadacdab<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp;\n0|0|11|0|100|0|11|011 aabacabd<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp;\n0|011|0|100|0|11|0|11 abacabab<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; ...<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; and so on<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">To prevent ambiguities in decoding, we will ensure that our\nencoding satisfies what's called the prefix rule which will result in uniquely decodable codes. The prefix rule states that no code is a prefix of\nanother code. By code, we mean the bits used for a particular character. In the above example, 0 is a prefix of 011 which violates the prefix rule. So if our\ncodes satisfy the prefix rule, the decoding will be unambiguous (and vice\nversa).<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">Let's consider the above example again. This time we assign codes\nthat satisfies the prefix rule to characters 'a', 'b', 'c', and 'd'.<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; a 0<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; b 10<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; c 110<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">&nbsp;&nbsp;&nbsp; d 111<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">Using the above codes, the string aabacdab will be encoded to\n00100100011010 (0|0|10|0|100|011|0|10). Now we can uniquely decode\n00100100011010 back to our original string \"aabacdab\".<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: x-large; font-weight: bold;\">Huffman Coding</span><o:p></o:p></p>\n\n<p class=\"MsoNormal\"><o:p>&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">Now that we are clear on variable-length encoding and prefix\nrule, let's talk about Huffman coding.<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">The technique works by creating a binary tree of nodes. A\nnode can be either a leaf node or an internal node. Initially, all nodes are\nleaf nodes, which contain the character itself, the weight (frequency of\nappearance) of the character. Internal nodes contain character weight and links\nto two child nodes. As a common convention, bit '0' represents following the\nleft child and bit '1' represents following the right child. A finished tree has\nn leaf nodes and n-1 internal nodes. It is recommended that the Huffman tree should\ndiscard unused characters in the text to produce the most optimal code lengths.<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">We will use a priority queue for building the Huffman tree where\nthe node with the lowest frequency is given the highest priority. Below are the\ncomplete steps -<o:p></o:p></span></p><p class=\"MsoNormal\"><span style=\"font-size: large;\"><br></span></p>\n\n<pre><code>1. Create a leaf node for each character and add them to the priority queue.<br><br>2. While there is more than one node in the queue:<br><br>    a. Remove the two nodes of highest priority (lowest frequency) from the queue<br><br>    b. Create a new internal node with these two nodes as children and with frequency equal to the sum of the two nodes' frequencies.<br><br>    c. Add the new node to the priority queue.<br><br>3. The remaining node is the root node and the tree is complete.</code></pre><p><br></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">Consider some text consisting of only 'A', 'B', 'C', 'D' and\n'E' character and their frequencies are 15, 7, 6, 6, 5 respectively. Below figures\nillustrate the steps followed by the algorithm -<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\"><br></o:p></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th style=\"text-align: left;\"><span style=\"font-size: x-large;\">Building a Huffman Tree</span></th></tr><tr><td style=\"text-align: left;\">&nbsp;<img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/Huffman-Coding-1.png?raw=true\" style=\"max-width:100%;\"></td></tr><tr><td style=\"text-align: left;\">&nbsp;<img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/Huffman-Coding-2.png?raw=true\" style=\"max-width:100%;\"></td></tr><tr><td style=\"text-align: left;\">&nbsp;<img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/Huffman-Coding-3.png?raw=true\" style=\"max-width:100%;\"></td></tr><tr><td style=\"text-align: left;\">&nbsp;<img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/Huffman-Coding-4.png?raw=true\" style=\"max-width:100%;\"></td></tr><tr><td style=\"text-align: left;\">&nbsp;<img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/Huffman-Coding-5.png?raw=true\" style=\"max-width:100%;\"></td></tr></tbody></table><p class=\"MsoNormal\"><o:p style=\"font-size: large;\"></o:p></p><p><br></p><p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p>\n\n<p class=\"MsoNormal\"><span style=\"font-size: large;\">The path from the root to any leaf node stores the optimal\nprefix code (also called Huffman code) corresponding to the character associated\nwith that leaf node.<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\"><o:p style=\"font-size: large;\">&nbsp;</o:p></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/Huffman-Coding-6.png?raw=true\" style=\"max-width:100%;\">&nbsp;</th></tr><tr><td>&nbsp;<span style=\"font-size: x-large;\">Completed Huffman Tree</span></td></tr></tbody></table><br><h1>Simulation</h1><p class=\"MsoNormal\"><span style=\"font-size: large;\">Below you can run both algorithms written in JavaScript.</span></p><iframe height=\"1200px\" width=\"100%\" src=\"https://phillipfeiding.github.io/huffman-coding/index.html\" scrolling=\"no\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" sandbox=\"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"></iframe><p><br></p><h1>Desktop Tool</h1><p><span style=\"font-size: large;\">Below is a JavaFX application that actually \"compresses\" and \"decompresses\" the files using binary encoding. <span style=\"font-weight: bold;\">Check that out by examining the file size.</span> You can download the .jar and try if you are interested.</span></p><p style=\"text-align: center;\"><a href=\"https://github.com/PhillipFeiDing/huffman-coding/raw/master/Huffman2.0/out/artifacts/Huffman2_0_jar/Huffman2.0.jar\" style=\"font-size: large;\" download=\"\">Huffman2.0.jar</a><br></p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/encoder.png?raw=true\" style=\"max-width:100%;\"></th><th><img src=\"https://github.com/PhillipFeiDing/myblog-resource/blob/master/huffman-coding/decoder.png?raw=true\" style=\"max-width:100%;\"></th></tr><tr><td style=\"text-align: center; \">&nbsp;<span style=\"font-weight: bold; font-size: large;\">Huffman Encoder Interface</span></td><td style=\"text-align: center; \">&nbsp;<span style=\"font-weight: bold; font-size: large;\">Huffman Decoder Interface</span></td></tr></tbody></table><p><br></p><h1>Repository Link</h1><p style=\"text-align: center; \"><a href=\"https://github.com/PhillipFeiDing/huffman-coding\" target=\"_blank\" style=\"font-size: large;\">Link to GitHub</a><br></p>",
        "time": 1544454000000,
        "exerpt": "In computer science and information theory, a Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. The process of finding or using such a code proceeds by means of Huffman coding, an algorithm developed by David A. Huffman while he was a Sc.D. student at MIT, and published in the 1952 paper \"A Method for the Construction of Minimum-Redundancy Codes\". This project provides an implementation of the classical Huffman encoding algorithms, an browser-based (JavaScript) demo interface, and a desktop (Java) utility tool available for download!",
        "tagList": [2, 7],
        "title": "Huffman Coding Algorithms",
        "imageURL": "https://github.com/PhillipFeiDing/myblog-resource/blob/master/blog-cover-image/huffman-js.png?raw=true"
    },
    "errno": 0
}